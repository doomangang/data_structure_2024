/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   hw3.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jihyjeon <jihyjeon@student.42seoul.kr>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/17 12:39:31 by jihyjeon          #+#    #+#             */
/*   Updated: 2024/04/17 13:17:05 by jihyjeon         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
/*
 * 1.
 *  (2) 원형 연결 리스트 - 마지막 노드가 처음을 가리키므로 NULL 을 가리키는 포인터가 없다.
 * 2.
 *  (1) 배열 - 연결 리스트와 다르게 n 번째 인덱스에 바로 arr[n] 과 같이 접근이 가능하다. 연결 리스트는 각 리스트가 병렬적으로 연결되어
 *  traverse 가 필요함.
 * 3.
 *  (3) last->link == NULL
 *   - 포인터 last 가 마지막 노드를 가리킨다. last 의 노드와 그 데이터는 유효하고,
 *   last->link == null 을 가리킴으로 연결리스트가 끝날 것이다. last->link->link 는 null->link 를 뜻하고 이는 참조 불가능
 * 4.
 *  (c) p = p->link
 *   p를 참조하면 어떤 노드가 나올 것이고, 그것의 다음 노드는 그의 link 를 참조하면 된다.
 * 5. p = p-> link;
 * 6. q = p;
 * 7. D
 *  - p = list->head 로 시작해, p->data = D 까지 p = p->link 로 움직입니다. 이 위치에서 p->link = NULL 이기 때문에
 *  반복문을 탈출합니다. 따라서 실행 후 p->data = D 를 가리키고 있습니다.
 *
 * 9번부터는 코드로 작성
 */

int main()